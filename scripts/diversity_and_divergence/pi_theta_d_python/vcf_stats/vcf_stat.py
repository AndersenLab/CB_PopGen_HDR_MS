# A collection of functions to pull and plot data from a VCF
import allel
import numpy as np
#import csv
#import sys
#import zarr 
#import numcodecs
#import matplotlib.pyplot as plt
#import seaborn as sns
import pandas as pd
#from scipy.signal import find_peaks
#from adjustText import adjust_text
#from matplotlib.patches import Rectangle

#For Divergent regions
import pyranges as pr

### Variant Density ##

def plot_windowed_variant_density(zarr, chroms, window_size, title=None):
    """
    Plots variant density for a single chromosome

    zarr: an opened zarr file obj
    chrom: list of strings representing group name in Zarr structure ex) "I"
    """

    #Set up plot
    n_chroms = len(chroms)

    #height = n_chroms * 5
    f , new = plt.subplots(n_chroms, sharey='all', figsize=(40, 20))
    
    for i in range(0, n_chroms): 
        chrom_id = chroms[i]
        chrom_zarr = zarr[chrom_id]
        pos = allel.SortedIndex(chrom_zarr['variants/POS'])


        # setup windows 
        bins = np.arange(0, pos.max(), window_size)
    
        # use window midpoints as x coordinate
        x = (bins[1:] + bins[:-1])/2
        
        # compute variant density in each window
        h, _ = np.histogram(pos, bins=bins)
        y = h / window_size #Divide the number of variants by the size of the window

        #Plot for the chromosome
        ax = new[i]
        ax.plot(x, y)
        ax.set_xlabel('Chromosome position (bp)')
        ax.set_ylabel('Variant density (bp$^{-1}$)')
        ax.set_title(chrom_id)

   
    
    


### Missing Sample Data ###

def plot_missing_gt_samples(zarr, chrom, title):
    chrom_zarr  = zarr[chrom] #Get the chromosome Zarr array 
    print(type(chrom_zarr))
    #Pull data - Should see if there is a better way so indexes don't get confused 
    chrom_gt_array = allel.GenotypeArray(chrom_zarr['calldata/GT'])
    print(type(chrom_gt_array))
    n_variants = len(chrom_gt_array)
    pc_missing = chrom_gt_array.count_missing(axis=0)[:] * 100 /n_variants
    
    fig, ax = plt.subplots(figsize=(12, 4))
    sns.despine(ax=ax, offset=10)
    left = np.arange(len(pc_missing))
    print(left)
    #palette = sns.color_palette()
    #pop2color = {'BFM': palette[0], 'AOM': palette[1]}
    #colors = [pop2color[p] for p in samples_subset.population]
    ax.bar(left, pc_missing)
    ax.set_xlim(0, len(pc_missing))
    ax.set_xlabel('Sample index')
    ax.set_ylabel('Percent calls')
    
    #return(fig)







### For windowed plotting


### Divergent Region functions ###

def call_divergent_windows(bed_path, windows, chrom): 
    """
    Helper function for windows plots to identify windows that overlap with divergent regions

    bed_path: path to all isotypes divegent bed
    windows: a numpy array returned from scikit-allele windowed statistic *Must be the same windows used to calculate x-axis
    chrom: chromosome to filter the bedfile to
    returns: overlaps bool from a windows object True means window overlaps with with range
    """

    #Load the bed file 
    hd_bed = pr.read_bed(bed_path)
    chrom_bed = hd_bed[chrom]

    #Create a pyranges obj from the window
    starts = windows[:,0]
    ends = windows[:, 1]
    windows_gr = pr.PyRanges(chromosomes= chrom, starts = starts, ends = ends)

    #Check for overlaps and store overlapping windows in a dictionary with start as keys
    overlaps = windows_gr.overlap(chrom_bed)
    overlaps = overlaps.df #Convert to a dataframe
    overlap_windows = overlaps.set_index('Start').T.to_dict() #Convert the overlaps to dict that can be quickly searched

    #Check if window is in divergent region dictionary
    divergent = []
    for i in range(len(windows)):
        start = windows[i, 0]
        if start in overlap_windows:
            div_bool = True
        else: 
            div_bool = False
        divergent.append(div_bool)
    return(divergent)


def get_divergent_blocks(div_bool):
    """
    Get start and number of bins that are divergent in a row
    
    div_bool: list of divergent region status for windows
    
    ex) div_bool = np.array([True,True,False,True,True,False,False])
        starts = [0, 3]
        ends = [1, ]
    """
    padded = np.hstack([False, div_bool, False])
    d = np.diff(padded.astype(int))
    starts = np.where(d == 1)# i of False -> True
    print(type(starts))
    ends = np.where(d == -1)# i of True -> false
                               #Gives the index of the false
    div_regions = np.concatenate((starts,ends))
    return(div_regions)
    
def make_divergent_recs(x, p, windowsize, div_regions, y_max = 1.0): 
    """
    Make a rectangle on the plot to indicate divergent region 

    x: x-axis for the plot that was created, must be generated from the same windows object as div_bool
    p: plot object generated by `fig , new = plt.subplots()`
    y_max: highest way value fo the plot
    div_regions: 2D np aray containing start and stop of divergent blocks
    """
    for i in range(len(div_regions[0])): 
        s_i = div_regions[0, i] #Index of start/end windows
        e_i = div_regions[1, i]

        start_x = x[s_i]
        start_y = 0

        end_x = x[e_i]

        width = ((end_x - (0.5 * int(windowsize))) - start_x)

        p.add_patch(Rectangle((start_x, start_y), width = width , height = y_max, facecolor ='pink', fill = True, alpha = 0.4))


def windowed_prop_gt_mis(zarr, chroms, windowsize, out=None, div_bed=None, peaks = False, varfreq = False, freqpeaks = False, div = False, save = False): 
    """
    If peaks is True the time to plot this increases significantly
    
    varfreq: wether or not to print a second plot of variant frequency. Can only be perfromed on len(chroms) == 1
    freqpeaks: wether or not to color marker to bins with >.8 prop gts missing
    div: wether or not to see what windows overlap with a divergent region, must be paired with div_bed
    div_bed: path to all strains bedfile (unzipped)
    """
    
    n_chroms = len(chroms)
    if varfreq == True:
        n_plts = 2
        fig, new = plt.subplots(n_plts, sharex="all" , figsize=(30, 10))
    else:
        fig, new = plt.subplots(n_chroms, sharey='all', figsize=(30, 10))
    
    for i in range(0, n_chroms):
        chrom_id = chroms[i]
        print("Working on: " + str(chrom_id))
        chrom_zarr = zarr[chrom_id]
        chrom_gt_array = allel.GenotypeArray(chrom_zarr['calldata/GT'])
        
        #Pull plot data
        pos = allel.SortedIndex(chrom_zarr["variants/POS"]) #Get array of variant positon
        n_missing = chrom_gt_array.count_missing(axis= 1)
        n_samples = int(chrom_gt_array.shape[1])
        
        #Calculate number of variants in the window
        def PropGT_windowed(wv):
            n_var_win = len(wv)
            #print("There are: " + str(n_var_win) +  " in the window")
            total_gt = n_var_win * n_samples
            missing = np.sum(wv) #add the total number of missing samples
            prop = missing / total_gt
            return(prop)
        y1 , windows, counts = allel.windowed_statistic(pos, n_missing, statistic= PropGT_windowed, size = windowsize, fill = 0)
        y2 = counts / windowsize #variant density
        x = windows.mean(axis = 1)
        label_x = x[np.where(y1 > .8)] #convert to array from nd array
        label_y = y1[np.where(y1 > .8)]
        counts_lab = counts[np.where(y1 > .8)]

        #Plotting for var freq and for single crhomosome

        if n_chroms == 1 & varfreq == False:
            ax = new
            #x = windows.mean(axis = 1) #Set up x-axis 
            y2 = (counts / windowsize)   #of variants / #BP in region * 100 - proportion of bases that are in window
            sns.despine(ax=ax, offset=10)
            ax.plot(x, y1, lw=0.25)
            ax.plot(x, y2, lw=0.25)
            if peaks == True:
                for i in range(0, len(label_y)): 
                    lab = counts_lab[i]
                    ax.text(label_x[i], label_y[i], s=f'{lab}')
        if n_chroms == 1 & varfreq == True & div == False:
            ax1 = new[0]
            ax2 = new[1]
            #x = windows.mean(axis = 1) #Set up x-axis 
            y2 = (counts / windowsize)   #of variants / #BP in region * 100 - proportion of bases that are in window
            y3 = counts
            #sns.despine(ax=ax, offset=10)
            line1 = ax1.plot(x, y1, lw=0.25, label = "Missing GTs")
            line2 = ax1.plot(x, y2, lw=0.25, label = "Variants")
            line3 = ax2.plot(x, y3, lw=0.25, label = "Variant Frequency")
            ax1.set_title(chrom_id)
            ax1.set_xlabel('Location (Kb)')
            ax1.set_ylabel('Proportion')
            ax1.legend()

            #ax1.legend(handles = [line1, line2])
            if freqpeaks == True:
                label_y = y3[np.where(y1 > .8)]
                marker = ax2.plot(label_x, label_y, marker = "o", ls="", ms = 2, color = "red" , label = "Window missing > .8 GTs")
                #ax2.legend(handles = [line3, marker])
                ax2.set_xlabel('Location (Kb)')
                ax2.set_ylabel('Variant Frequency')
                ax2.legend()
                if save == True:
                    fig.savefig(out, facecolor = 'w', bbox_inches='tight') #Make the background white and remove extra whitespace
                    fig.show()
            if save == True: 
                fig.savefig(out, facecolor = 'w', bbox_inches='tight') #Make the background white and remove extra whitespace
            else:
                fig.show()
            # if peaks == True:
            #     for i in range(0, len(label_y)): 
            #         lab = counts_lab[i]
            #         ax.text(label_x[i], label_y[i], s=f'{lab}')
        
        ## Plotting for divergent regions ##

        if n_chroms == 1 & varfreq == True & div == True:
            ax1 = new[0]
            ax2 = new[1]
            #x = windows.mean(axis = 1) #Set up x-axis 
            y2 = (counts / windowsize)   #of variants / #BP in region * 100 - proportion of bases that are in window
            y3 = counts
            #sns.despine(ax=ax, offset=10)
            line1 = ax1.plot(x, y1, lw=0.25, label = "Missing GTs")
            line2 = ax1.plot(x, y2, lw=0.25, label = "Variants")
            line3 = ax2.plot(x, y3, lw=0.25, label = "Variant Frequency")
            ax1.set_title(chrom_id)
            ax1.set_xlabel('Location (Kb)')
            ax1.set_ylabel('Proportion')
            ax1.legend()
            if div == True:
                div_windows = call_divergent_windows(div_bed, windows, chrom_id)
                div_regions = get_divergent_blocks(div_windows)
                make_divergent_recs(x , ax1, windowsize, div_regions)
                y3_max = y3.max()
                make_divergent_recs(x, ax2, windowsize, div_regions, y_max = y3_max) #Make divergent region highlighting on variant density plot

            #ax1.legend(handles = [line1, line2])
            if freqpeaks == True:
                label_y = y3[np.where(y1 > .8)]
                marker = ax2.plot(label_x, label_y, marker = "o", ls="", ms = 2, color = "red",label = "Window missing > .8 GTs")
                #ax2.legend(handles = [line3, marker])
                ax2.set_xlabel('Location (Kb)')
                ax2.set_ylabel('Variant Frequency')
                ax2.legend()
                if div == True:
                    div_windows = call_divergent_windows(div_bed, windows, chrom_id)
                    div_regions = get_divergent_blocks(div_windows)
                    make_divergent_recs(x, ax1, windowsize, div_regions)
                    y3_max = y3.max()
                    make_divergent_recs(x, ax2, windowsize, div_regions, y_max = y3_max)
                if save == True:
                    fig.savefig(out, facecolor = 'w', bbox_inches='tight') #Make the background white and remove extra whitespace
                    fig.show()
                if save == False: 
                    fig.show()
            else:
                if save == True: 
                    fig.savefig(out, facecolor = 'w', bbox_inches='tight') #Make the background white and remove extra whitespace
                    fig.show()
                if save == False:
                    fig.show()

        #Plotting for >1 chromosomes and no var freq

        else:
            ax = new[i]
            #x = windows.mean(axis = 1) #Set up x-axis 
            y2 = (counts / windowsize) * 100   #of variants / #BP in region * 100 - proportion of bases that are in window
            sns.despine(ax=ax, offset=10)
            ax.plot(x, y1, lw=0.25)
            ax.plot(x, y2, lw=0.25)
            if peaks == True:
                texts = [] #store the label obj to gitter
                for i in range(0, len(label_y)): 
                    lab = counts_lab[i]
                    texts.append(ax.text(label_x[i], label_y[i], s=f'{lab}'))
                    adjust_text(texts, only_move={'points':'y', 'texts':'y'}, arrowprops=dict(arrowstyle="->", color='r', lw=0.5))





def windowed_prop_samp_mis_gt(zarr, chroms, windowsize, peaks = False): 
    """
    Calculate percent of samples missing data for each variant and computes mean prop missing sample along chrom window
        * Does not actually plot the data **
    
    zarr: opened zarr data file
    windowsize: non-overlapping bp size
    chrom: str representing group name in Zarr structure ex) "I"
    Retuns: Outputs from allel.windowed statistics, a tuple of arrays (stat, windows, counts)
    
    Plot with: (see 04.02.2022 jupyter notebook for faceting or more details)
    x = windows.mean(axis = 1)
    #Optional - Get variant density metric
    y2 = _ / 10000 * 100  #Counts can serve as a proxy for variant density - want to variant denisty
         #of variants / #BP in region * 100 - proportion of bases that are in window
    fig, ax = plt.subplots(figsize=(15, 4))
    sns.despine(ax=ax, offset=10)
    ax.plot(x, y, lw=1)
    ax.plot(x, y2, lw=1)
    """
    n_chroms = len(chroms)
    fig_height = n_chroms * 5
    fig, new = plt.subplots(n_chroms, sharey='all', figsize=(30, fig_height))

    for i in range(0, n_chroms):
        chrom_id = chroms[i]
        print("Working on: " + str(chrom_id))
        chrom_zarr = zarr[chrom_id]
    
    
        #Pull data - Should see if there is a better way so indexes don't get confused 
        chrom_gt_array = allel.GenotypeArray(chrom_zarr['calldata/GT'])
        chrom_pos = chrom_zarr['variants/POS'][:] #Get array of variant positon
        
        
        #For each variant calculate the proportion of samples missing genotype data
        n_samples = chrom_gt_array.shape[1] #Pull number of samples from gt array
        missing_by_variant = chrom_gt_array.count_missing(axis = 1) #Count the number of samples with missing gt data
        pc_missing = missing_by_variant * 100 / n_samples #Calculate percent of samples missing data

        
        #Calculate window stats
        y, windows, counts = allel.windowed_statistic(pos = chrom_pos, 
                            values = pc_missing, 
                            statistic=np.mean,
                            size = windowsize)
        x = windows.mean(axis = 1) #Set up x-axis 
        label_x = x[np.where(y > 80)] #convert to array from nd array
        label_y = y[np.where(y > 80)]
        counts_lab = counts[np.where(y > 80)]
            

        if n_chroms == 1:
            ax = new
            #x = windows.mean(axis = 1) #Set up x-axis 
            y2 = (counts / windowsize) * 100   #of variants / #BP in region * 100 - proportion of bases that are in window
            sns.despine(ax=ax, offset=10)
            ax.plot(x, y, lw=1)
            ax.plot(x, y2, lw=1)
            if peaks == True:
                for i in range(0, len(label_y)): 
                    lab = counts_lab[i]
                    ax.text(label_x[i], label_y[i], s=f'{lab}')

        else:
            ax = new[i]
            #x = windows.mean(axis = 1) #Set up x-axis 
            y2 = (counts / windowsize) * 100   #of variants / #BP in region * 100 - proportion of bases that are in window
            sns.despine(ax=ax, offset=10)
            ax.plot(x, y, lw=1)
            ax.plot(x, y2, lw=1)
            if peaks == True:
                texts = [] #store label obj to gitter
                for i in range(0, len(label_y)): 
                    lab = counts_lab[i]
                    texts.append(ax.text(label_x[i], label_y[i], s=f'{lab}'))
                    adjust_text(texts, only_move={'points':'y', 'texts':'y'}, arrowprops=dict(arrowstyle="->", color='r', lw=0.5))





## Proportion of missing GTs by sample - Chrom ##

def plot_mis_gt_sample(zarr, chroms, threshold):
    """
    Plots the proportion of GT's missing by sample

    zarr: open zarr file 
    chroms: list of strings representing group name in Zarr structure ex) "I"
    thereshold: Proportion of GTs missing which will result in a strain label being added to the bar
    """
    n_chroms = len(chroms)
    #height = n_chroms * 5
    f , new = plt.subplots(n_chroms, sharey='all', figsize=(40, 25))
    
    for i in range(0, n_chroms):
        chrom_id = chroms[i]
        print("Working on: " + str(chrom_id))
        chrom_zarr = zarr[chrom_id]

        chrom_gt_array = allel.GenotypeArray(chrom_zarr['calldata/GT'])
        samples = chrom_zarr['samples'][:]

        nvar = len(chrom_gt_array)
        print("There are " + str(nvar) + " variants")
        pc_missing = chrom_gt_array.count_missing(axis=0)[:] * 100 / nvar
        #Plot figure
        ax = new[i]
        left = np.arange(len(pc_missing))
        bars = ax.bar(left, pc_missing, align = 'edge')
        for bar in bars: 
            height = bar.get_height()
            if height > threshold: 
                label_x_pos = bar.get_x()
                samp_id = samples[label_x_pos]
                print("Making bar ID for" + str(bar))
                label_y_pos = bar.get_height()
                ax.text(label_x_pos, label_y_pos, s=f'{samp_id}')
        ax.set_xlim(0, len(pc_missing))
        ax.set_title(chrom_id)
        ax.set_xlabel('Sample index')
        ax.set_ylabel('Percent Missing GT calls')





